'use client';

import Image from "next/image";
import { useState, useRef, useEffect, useCallback, useMemo, memo } from "react";
import dynamic from "next/dynamic";
import ResponsiveLogo from "../components/ResponsiveLogo";
import NavigationWheel from "../components/NavigationWheel";
import ProductCard from "../components/ProductCard";

// Dynamic imports for performance optimization
const WebVitalsMonitor = dynamic(() => import("../components/WebVitalsMonitor"), {
  ssr: false,
  loading: () => null,
});

const MemoryManager = dynamic(() => import("../components/MemoryManager"), {
  ssr: false,
  loading: () => null,
});

const ErrorBoundary = dynamic(() => import("../components/ErrorBoundary"), {
  ssr: false,
  loading: () => null,
});

const ServiceWorkerRegistration = dynamic(() => import("../components/ServiceWorkerRegistration"), {
  ssr: false,
  loading: () => null,
});

export default function Home() {
  // Core state management
  const [currentIndex, setCurrentIndex] = useState(0);
  const [translateX, setTranslateX] = useState(0);
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, translate: 0, timestamp: 0 });
  const [isInitialized, setIsInitialized] = useState(false);

  const sliderRef = useRef(null);
  const containerRef = useRef(null);  // Memoized product data to prevent unnecessary re-renders
  const products = useMemo(() => [
    { id: 1, name: "GAME ON 49", image: "/product/condom-product-GAME ON-49.png" },
    { id: 2, name: "GAME ON 52", image: "/product/condom-product-GAME ON-52.png" },
    { id: 3, name: "GAME ON 54", image: "/product/condom-product-GAME ON-54.png" },
    { id: 4, name: "GAME ON 56", image: "/product/condom-product-GAME ON-56.png" },
    { id: 5, name: "GAME ON 60", image: "/product/condom-product-GAME ON-60.png" },
  ], []);
  // Loop configuration with responsive card width
  const [cardWidth, setCardWidth] = useState(500);
  const [cardHeight, setCardHeight] = useState(896); // 56rem = 896px
  const [wheelSize, setWheelSize] = useState(128); // Dynamic wheel size
  const [logoSize, setLogoSize] = useState({ width: 200, height: 120 }); // Dynamic logo size
  
  // Memoized constants to prevent recalculation
  const { TOTAL_PRODUCTS, LOOP_SETS, CENTER_SET } = useMemo(() => ({
    TOTAL_PRODUCTS: products.length,
    LOOP_SETS: 3, // Render 3 complete sets
    CENTER_SET: 1, // Index of the center set (0, 1, 2)
  }), [products.length]);
  // Memoized dimension calculations for performance
  const calculateDimensions = useCallback((width, height) => {
    // Base dimensions
    let cardW = 500;
    let cardH = 896;
    let wheelW = 128;
    let logoW = 200;
    let logoH = 120;
    
    // Responsive adjustments for smaller screens
    if (width < 360) {
      // Very small phones
      cardW = Math.min(250, width * 0.65);
      cardH = cardW * 1.792;
      wheelW = Math.min(80, width * 0.22);
      logoW = Math.min(120, width * 0.33);
      logoH = logoW * 0.6;
    } else if (width < 480) {
      // Small phones
      cardW = Math.min(280, width * 0.7);
      cardH = cardW * 1.792;
      wheelW = Math.min(96, width * 0.2);
      logoW = Math.min(140, width * 0.29);
      logoH = logoW * 0.6;
    } else if (width < 640) {
      // Large phones
      cardW = Math.min(320, width * 0.75);
      cardH = cardW * 1.792;
      wheelW = Math.min(128, width * 0.2);
      logoW = Math.min(160, width * 0.25);
      logoH = logoW * 0.6;
    } else if (width < 768) {
      // Small tablets
      cardW = Math.min(400, width * 0.8);
      cardH = cardW * 1.792;
      wheelW = Math.min(160, width * 0.21);
      logoW = Math.min(200, width * 0.26);
      logoH = logoW * 0.6;
    } else if (width < 1024) {
      // Tablets
      cardW = Math.min(450, width * 0.75);
      cardH = cardW * 1.792;
      wheelW = Math.min(192, width * 0.19);
      logoW = Math.min(240, width * 0.23);
      logoH = logoW * 0.6;
    } else if (width < 1280) {
      // Small laptops
      cardW = 500;
      cardH = 896;
      wheelW = Math.min(256, width * 0.2);
      logoW = Math.min(280, width * 0.22);
      logoH = logoW * 0.6;
    } else if (width < 1536) {
      // Large laptops
      cardW = 500;
      cardH = 896;
      wheelW = Math.min(320, width * 0.21);
      logoW = Math.min(320, width * 0.21);
      logoH = logoW * 0.6;
    } else if (width < 1920) {
      // Desktop
      cardW = 500;
      cardH = 896;
      wheelW = Math.min(400, width * 0.21);
      logoW = Math.min(360, width * 0.19);
      logoH = logoW * 0.6;
    } else {
      // Large desktop/ultrawide
      cardW = 500;
      cardH = 896;
      wheelW = Math.min(640, width * 0.33);
      logoW = Math.min(400, width * 0.21);
      logoH = logoW * 0.6;
    }
    
    // Adjust wheel size based on viewport height for better proportions
    const heightRatio = height / 1080; // Normalize to 1080p
    wheelW = Math.max(80, Math.min(wheelW, wheelW * heightRatio * 1.2));
    
    // Adjust logo size based on viewport height for better proportions
    logoH = Math.max(60, Math.min(logoH, logoH * heightRatio * 1.1));
    logoW = logoH / 0.6; // Maintain aspect ratio
    
    // Ensure dimensions don't exceed reasonable bounds
    wheelW = Math.max(80, Math.min(wheelW, 640));
    logoW = Math.max(100, Math.min(logoW, 400));
    logoH = Math.max(60, Math.min(logoH, 240));
    
    return { cardW, cardH, wheelW, logoW, logoH };
  }, []);

  // Set responsive card dimensions and wheel size
  useEffect(() => {
    const updateDimensions = () => {
      if (typeof window !== 'undefined') {
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        const { cardW, cardH, wheelW, logoW, logoH } = calculateDimensions(width, height);
        
        setCardWidth(cardW);
        setCardHeight(cardH);
        setWheelSize(wheelW);
        setLogoSize({ width: logoW, height: logoH });
      } else {
        // Default dimensions for SSR
        setCardWidth(500);
        setCardHeight(896);
        setWheelSize(128);
        setLogoSize({ width: 200, height: 120 });
      }
    };

    updateDimensions();
    
    // Add resize listener with throttling
    let timeoutId;
    const handleResize = () => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(updateDimensions, 100);
    };
    
    window.addEventListener('resize', handleResize);    return () => {
      window.removeEventListener('resize', handleResize);
      clearTimeout(timeoutId);
    };
  }, [calculateDimensions]);

  // Calculate the position for centering a product
  const getCenterPosition = useCallback((productIndex) => {
    if (!containerRef.current) return 0;

    const containerWidth = containerRef.current.offsetWidth;
    const viewportCenter = containerWidth / 2;
    const cardCenter = cardWidth / 2;

    // Position in center set
    const centerSetOffset = CENTER_SET * TOTAL_PRODUCTS * cardWidth;
    const productOffset = productIndex * cardWidth;

    return viewportCenter - cardCenter - centerSetOffset - productOffset;
  }, [cardWidth, TOTAL_PRODUCTS, CENTER_SET]);  // Handle infinite loop boundary repositioning
  const handleLoopBoundaries = useCallback((currentTranslate) => {
    const setWidth = TOTAL_PRODUCTS * cardWidth;

    // More generous boundaries to ensure smooth transitions
    const leftBoundary = setWidth * 0.3; // When we're too far right (positive values)
    const rightBoundary = -setWidth * 1.7; // When we're too far left (negative values)

    if (currentTranslate > leftBoundary) {
      // Moved too far right, shift to left set (more negative)
      return currentTranslate - setWidth;
    } else if (currentTranslate < rightBoundary) {
      // Moved too far left, shift to right set (less negative)
      return currentTranslate + setWidth;
    }

    return currentTranslate;
  }, [cardWidth, TOTAL_PRODUCTS]);// Navigate to specific product with improved infinite loop handling
  const navigateToProduct = useCallback((targetIndex) => {
    // Normalize index to valid range
    const normalizedIndex = ((targetIndex % TOTAL_PRODUCTS) + TOTAL_PRODUCTS) % TOTAL_PRODUCTS;

    console.log(`Navigating from ${currentIndex} to ${normalizedIndex} (original target: ${targetIndex})`);
    console.log(`Current translateX: ${translateX}`);

    setCurrentIndex(normalizedIndex);

    // Calculate the target position
    let newTranslate = getCenterPosition(normalizedIndex);
    // For smooth infinite loop, check if we need to adjust position based on current translate
    // This handles cases where we're transitioning from last to first or first to last
    if (Math.abs(translateX) > 0) {
      const setWidth = TOTAL_PRODUCTS * cardWidth;

      console.log(`Set width: ${setWidth}`);

      // If we're transitioning from last product (4) to first product (0)
      if (currentIndex === TOTAL_PRODUCTS - 1 && normalizedIndex === 0) {
        console.log('Transitioning from last to first - adjusting for smooth scroll');
        // Move to the next set to maintain smooth scrolling
        newTranslate -= setWidth;
      }
      // If we're transitioning from first product (0) to last product (4)
      else if (currentIndex === 0 && normalizedIndex === TOTAL_PRODUCTS - 1) {
        console.log('Transitioning from first to last - adjusting for smooth scroll');
        // Move to the previous set to maintain smooth scrolling
        newTranslate += setWidth;
      }
    }

    console.log(`Initial newTranslate: ${newTranslate}`);

    // Apply boundary handling to ensure we're in the correct set
    newTranslate = handleLoopBoundaries(newTranslate);

    console.log(`Final newTranslate after boundaries: ${newTranslate}`);
    setTranslateX(newTranslate);  }, [getCenterPosition, translateX, currentIndex, handleLoopBoundaries, cardWidth, TOTAL_PRODUCTS]);  // Calculate which product is currently centered
  const getCurrentProductFromPosition = useCallback((translate) => {
    if (!containerRef.current) return 0;

    const containerWidth = containerRef.current.offsetWidth;
    const viewportCenter = containerWidth / 2;
    const cardCenter = cardWidth / 2;

    // Calculate the product position that would be centered
    const centerSetOffset = CENTER_SET * TOTAL_PRODUCTS * cardWidth;
    const targetPosition = viewportCenter - cardCenter - translate - centerSetOffset;
    const productIndex = Math.round(targetPosition / cardWidth);

    return ((productIndex % TOTAL_PRODUCTS) + TOTAL_PRODUCTS) % TOTAL_PRODUCTS;
  }, [cardWidth, TOTAL_PRODUCTS, CENTER_SET]);
  // Initialize slider position
  useEffect(() => {
    if (!isInitialized && containerRef.current) {
      setIsInitialized(true);
      const initialPosition = getCenterPosition(0);
      setTranslateX(initialPosition);
    }
  }, [isInitialized, getCenterPosition]);
  // Handle window resize with enhanced wheel repositioning
  useEffect(() => {
    const handleResize = () => {
      if (isInitialized) {
        const newPosition = getCenterPosition(currentIndex);
        setTranslateX(newPosition);
        // Wheel size is already handled in the updateDimensions useEffect
      }
    };

    let timeoutId;
    const throttledResize = () => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(handleResize, 100);
    };

    window.addEventListener('resize', throttledResize);
    return () => {
      window.removeEventListener('resize', throttledResize);
      clearTimeout(timeoutId);
    };
  }, [isInitialized, currentIndex, getCenterPosition]);// Mouse event handlers with enhanced physics
  const handleMouseDown = useCallback((e) => {
    setIsDragging(true);
    const currentTime = Date.now();
    setDragStart({ 
      x: e.clientX, 
      translate: translateX, 
      timestamp: currentTime
    });

    if (sliderRef.current) {
      sliderRef.current.style.cursor = 'grabbing';
    }
  }, [translateX]);  const handleMouseMove = useCallback((e) => {
    if (!isDragging) return;

    const deltaX = e.clientX - dragStart.x;
    
    // Apply smooth boundary resistance
    const maxDelta = cardWidth * 1.2;
    const resistance = 0.4;
    let constrainedDelta = deltaX;
    
    if (Math.abs(deltaX) > maxDelta) {
      const excess = Math.abs(deltaX) - maxDelta;
      const resistedExcess = Math.pow(excess / maxDelta, 0.7) * maxDelta * resistance;
      constrainedDelta = deltaX > 0 ? maxDelta + resistedExcess : -(maxDelta + resistedExcess);
    }
    
    let newTranslate = dragStart.translate + constrainedDelta;

    // Handle loop boundaries during drag
    newTranslate = handleLoopBoundaries(newTranslate);
    setTranslateX(newTranslate);
  }, [isDragging, dragStart, handleLoopBoundaries, cardWidth]);const handleMouseUp = useCallback(() => {
    if (!isDragging) return;

    setIsDragging(false);
    
    if (sliderRef.current) {
      sliderRef.current.style.cursor = 'grab';
    }

    // Determine if we should snap based on drag distance
    const dragDistance = translateX - dragStart.translate;
    const threshold = cardWidth * 0.25; // Reduced threshold for more responsive feel
    
    let targetIndex = currentIndex;
    if (Math.abs(dragDistance) > threshold) {
      if (dragDistance > 0) {
        targetIndex = currentIndex - 1; // Dragged right
      } else {
        targetIndex = currentIndex + 1; // Dragged left
      }
    }
    navigateToProduct(targetIndex);
  }, [isDragging, translateX, dragStart, cardWidth, currentIndex, navigateToProduct]);  // Touch event handlers with enhanced physics
  const handleTouchStart = useCallback((e) => {
    setIsDragging(true);
    const currentTime = Date.now();
    setDragStart({ 
      x: e.touches[0].clientX, 
      translate: translateX, 
      timestamp: currentTime
    });
  }, [translateX]);  const handleTouchMove = useCallback((e) => {
    if (!isDragging) return;

    const deltaX = e.touches[0].clientX - dragStart.x;
    
    // Apply smooth boundary resistance for touch
    const maxDelta = cardWidth * 1.5;
    const resistance = 0.4;
    let constrainedDelta = deltaX;
    
    if (Math.abs(deltaX) > maxDelta) {
      const excess = Math.abs(deltaX) - maxDelta;
      const resistedExcess = Math.pow(excess / maxDelta, 0.7) * maxDelta * resistance;
      constrainedDelta = deltaX > 0 ? maxDelta + resistedExcess : -(maxDelta + resistedExcess);
    }
    
    let newTranslate = dragStart.translate + constrainedDelta;

    // Handle loop boundaries during drag
    newTranslate = handleLoopBoundaries(newTranslate);
    setTranslateX(newTranslate);
  }, [isDragging, dragStart, cardWidth, handleLoopBoundaries]);const handleTouchEnd = useCallback(() => {
    if (!isDragging) return;

    setIsDragging(false);

    // Determine if we should snap based on drag distance
    const dragDistance = translateX - dragStart.translate;
    const threshold = cardWidth * 0.2; // Even more responsive for touch
    
    let targetIndex = currentIndex;
    if (Math.abs(dragDistance) > threshold) {
      if (dragDistance > 0) {
        targetIndex = currentIndex - 1;
      } else {
        targetIndex = currentIndex + 1;
      }
    }
    navigateToProduct(targetIndex);
  }, [isDragging, translateX, dragStart, cardWidth, currentIndex, navigateToProduct]);

  // Global event listeners for smooth dragging
  useEffect(() => {
    if (!isDragging) return;

    const handleGlobalMouseMove = (e) => handleMouseMove(e);
    const handleGlobalMouseUp = () => handleMouseUp();

    document.addEventListener('mousemove', handleGlobalMouseMove);
    document.addEventListener('mouseup', handleGlobalMouseUp);
    document.body.style.userSelect = 'none';

    return () => {
      document.removeEventListener('mousemove', handleGlobalMouseMove);
      document.removeEventListener('mouseup', handleGlobalMouseUp);
      document.body.style.userSelect = '';
    };
  }, [isDragging, handleMouseMove, handleMouseUp]);
  // Enhanced wheel click handler
  const handleWheelClick = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    
    // Get click position relative to wheel center
    const rect = e.currentTarget.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const clickX = e.clientX - centerX;
    const clickY = e.clientY - centerY;
    
    // Calculate angle from center to click point
    const angle = Math.atan2(clickY, clickX) * (180 / Math.PI);
    const normalizedAngle = (angle + 360) % 360;
    
    // Calculate which segment was clicked
    const segmentAngle = 360 / products.length;
    const currentRotation = (-currentIndex * segmentAngle + 360) % 360;
    const relativeAngle = (normalizedAngle - currentRotation + 360) % 360;
    const clickedSegment = Math.round(relativeAngle / segmentAngle) % products.length;
    
    // Navigate to clicked segment
    if (clickedSegment !== currentIndex) {
      navigateToProduct(clickedSegment);
    }
  }, [currentIndex, products.length, navigateToProduct]);  return (
    <ErrorBoundary>
      <div className="min-h-screen flex flex-col relative" style={{ backgroundColor: '#070A1B' }}>
      {/* Optimized Logo Component */}
      <ResponsiveLogo logoSize={logoSize} />{/* Main content area with responsive spacing and mobile optimization */}
      <div 
        className="flex-1 flex flex-col justify-center items-center px-2 sm:px-4 md:px-6 lg:px-8 pb-20 sm:pb-24 md:pb-32 lg:pb-40 xl:pb-48"
        style={{
          paddingTop: typeof window !== 'undefined' ? 
            window.innerWidth < 480 ? 
              `${logoSize.height + 32}px` : // Logo height + 2rem
            window.innerWidth < 768 ? 
              `${logoSize.height + 40}px` : // Logo height + 2.5rem
            window.innerWidth < 1024 ? 
              `${logoSize.height + 48}px` : // Logo height + 3rem
              `${logoSize.height + 64}px`   // Logo height + 4rem
            : '6rem' // Fallback for SSR
        }}
      >
        {/* Slider Container with responsive constraints */}
        <div className="w-full max-w-full overflow-x-hidden">
          <div
            ref={containerRef}
            className="w-full overflow-hidden relative"
            style={{
              // Ensure minimum height for mobile devices
              minHeight: typeof window !== 'undefined' && window.innerWidth < 768 ? '60vh' : 'auto'
            }}
          >
            {/* Product Slider with Improved Infinite Loop */}
            <div
              ref={sliderRef}
              className="flex cursor-grab select-none"              style={{
                transform: `translateX(${translateX}px)`,
                transition: isDragging ? 'none' : 'transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)',
                gap: '0px',
                width: 'max-content'
              }}
              onMouseDown={handleMouseDown}
              onTouchStart={handleTouchStart}
              onTouchMove={handleTouchMove}
              onTouchEnd={handleTouchEnd}
              onDragStart={(e) => e.preventDefault()}
            >              {/* Render multiple sets for seamless infinite loop */}
              {Array.from({ length: LOOP_SETS }, (_, setIndex) =>
                products.map((product, productIndex) => {
                  // Calculate if this is the center product
                  const isCenter = setIndex === CENTER_SET && productIndex === currentIndex;
                  
                  // Calculate distance from center for scaling (considering all sets)
                  let distanceFromCenter;
                  if (setIndex === CENTER_SET) {
                    // Same set as center
                    distanceFromCenter = Math.abs(productIndex - currentIndex);
                  } else {
                    // Different set - calculate cross-set distance
                    const setOffset = (setIndex - CENTER_SET) * TOTAL_PRODUCTS;
                    const absolutePosition = productIndex + setOffset;
                    distanceFromCenter = Math.abs(absolutePosition - currentIndex);
                  }
                  
                  const normalizedDistance = Math.min(distanceFromCenter, TOTAL_PRODUCTS - distanceFromCenter); // Handle wrap-around                  // Responsive scale based on distance and screen size
                  let scale = 1;
                  let opacity = 1;
                  
                  // Get responsive scale factors
                  const isMobile = typeof window !== 'undefined' && window.innerWidth < 768;
                  const centerScale = isMobile ? 1.2 : 1.4;
                  const adjacentScale = isMobile ? 0.9 : 1.0;
                  const distantScale = isMobile ? 0.6 : 0.7;
                  
                  if (isCenter) {
                    scale = centerScale;
                    opacity = 1.0;
                  } else if (normalizedDistance === 1) {
                    scale = adjacentScale;
                    opacity = 0.7;
                  } else {
                    // Distance 2+ cards - always completely hidden on all screen sizes
                    scale = distantScale;
                    opacity = 0;
                  }                  return (
                    <ProductCard
                      key={`set-${setIndex}-product-${product.id}`}
                      product={product}
                      setIndex={setIndex}
                      productIndex={productIndex}
                      isCenter={isCenter}
                      normalizedDistance={normalizedDistance}
                      scale={scale}
                      opacity={opacity}
                      cardWidth={cardWidth}
                      cardHeight={cardHeight}
                      isMobile={isMobile}
                    />
                  );
                })
              ).flat()}
            </div>
          </div>
        </div>      </div>      {/* Optimized Navigation Wheel Component */}
      <NavigationWheel 
        wheelSize={wheelSize}
        currentIndex={currentIndex}
        products={products}
        isDragging={isDragging}
        handleWheelClick={handleWheelClick}
      />      {/* Performance Monitoring Components */}
      <WebVitalsMonitor />
      <MemoryManager />
      <ServiceWorkerRegistration />
      </div>
    </ErrorBoundary>
  );
}
